=encoding utf8

=head1 NAME

Object::Simple::Guide::Ja - Object::Simpleのガイドブック

=head1 ガイドブック

=head2 概要

オブジェクト指向プログラミング
のひとつのよい習慣は、メソッドのみによってオブジェクト
が持っているデータにアクセスすることです。
オブジェクトが持っているデータを属性値と呼びます。
属性値を取得・設定するためのメソッドをアクセッサと呼びます。

アクセッサの定義は通常は次のようになります。

    package Point;
    
    sub x {
        my $self = shift;
        
        if (@_) {
            $self->{x} = $_[0];
        }
        return $self->{x};
    }

オブジェクトはたくさんの属性値を持つことが多いですから、
アクセッサを簡単な方法で作成したいと思うことでしょう。

L<Object::Simple>はアクセッサを生成するためのメソッドを提供します。
次の記述でアクセッサを生成することができます。

    __PACKAGE__->attr('x');

Perlのモジュールの中にはアクセッサを生成するための
モジュールが他にも、L<Object::Simple>の特徴は
次のとおりです。

L<Object::Simple>を利用すると、属性値にデフォルト値
を持たせることができます。これは
L<Class::Accessor::Fast>に対する利点です。

    __PACAKGE__->attr(x => 0);

L<Object::Simple>はコンストラクタであるC<new()>を提供します。
コンストラクタはハッシュとハッシュのリファレンス
を受け取ることができます。

    my $point = Point->new(x => 1, y => 1);
    my $point = Point->new({x => 1, y => 1});

これもL<Class::Accessor::Fast>に対する利点です。
L<Class::Accessor::Fast>のC<new()>はハッシュリファレンス
しか受け取ることができないからです。

L<Object::Simple>を利用すると、きわめて短い記述でアクセッサ
を定義することができます。
C<attr()>を使って、すべてのアクセッサを定義することもできます。

    __PACKAGE__->attr(
        [qw/foo bar baz/],
        some => 1,
        other => sub { 5 }
    );

これはL<Moose>などのクラスビルダーに対する利点です。

L<Object::Simple>には機能が足りないのではないかと
感じる方もいるかもしれませんが、
デフォルト値を定義する機能さえあればほとんどの場合に
十分です。
たとえばL<Mojolicious>という大きななWebフレームワーク
のアクセッサでは
デフォルト値を定義する機能だけを用いています。

L<Object::Simpel>はプログラマが使いやすいように設計されています。
L<Object::Simpel>を使ってみたいと思われた方は
以下の解説を読んでみてください。

=head2 1. アクセッサの生成

最初にL<Object::Simple>を継承したクラスを作成します

    package MyClass;
    
    use base 'Object::Simple';

継承はC<base>モジュールを使って行うのが一般的です。

L<Object::Simple>はC<new()>を持っています。
C<new()>はコンストラクタであり
ハッシュあるいはハッシュのリファレンスを受け取ることができます。
    
    my $obj = MyClass->new;
    my $obj = MyClass->new(foo => 1, bar => 2);
    my $obj = MyClass->new({foo => 1, bar => 2});

アクセッサを生成するにはC<attr()>メソッドを使用します。

    __PACKAGE__->attr('foo');

生成されたアクセッサを使って属性値を設定したり取得することができます。

    # 属性値の設定
    $obj->foo(1);
    
    # 属性値の取得
    my $foo = $obj->foo;

C<attr()>では、アクセッサのためのデフォルト値を指定することもできます。

    __PACKAGE__->attr(foo => 1);

属性値が設定されていない場合は最初にアクセッサが呼び出されたときに
デフォルト値が属性値に設定されます。

    my $default_value = $obj->foo;

もしリファレンスやオブジェクトをデフォルト値として指定したい場合は
サブルーチンのリファレンスの戻り値にする必要があります。
これはデフォルト値を他のオブジェクトと共有しないためです。

    __PACKAGE__->attr(foo => sub { [] });
    __PACKAGE__->attr(foo => sub { {} });
    __PACKAGE__->attr(foo => sub { MyClass->new });

複数のアクセッサを一度に生成することができます。

    __PACKAGE__->attr([qw/foo bar baz/]);
    __PACKAGE__->attr([qw/foo bar baz/] => 0);

すべてのアクセッサを一度に生成することもできます。

    __PACKAGE__->attr(
        [qw/foo bar baz/],
        some => 1,
        other => sub { 5 }
    );

引数が奇数個の場合には、一つ目の引数に渡された値は、
デフォルト値を持たないアクセッサです。
それ以降は、デフォルト値を持つアクセッサの定義になります。

=head2 クラスの作成

L<Object::Simple>を継承してクラスを作成してみましょう。
PointクラスとPoint3Dクラスを作成してみます。

B<Pointクラス:>

C<Point>は点を表すクラスです。
C<x>とC<y>というアクセッサと、
C<x>とC<y>の値を0にクリアする<clear>というメソッドを持ちます。

    package Point;
    
    use strict;
    use warnings;
    
    use base 'Object::Simple';

    __PACKAGE__->attr(x => 0);
    __PACKAGE__->attr(y => 0);
    
    sub clear {
        my $self = shift;
        
        $self->x(0);
        $self->y(0);
    }

Pointクラスは以下のように使用することができます。

    use Point;
    my $point = Point->new(x => 3, y => 5);
    print $point->x;
    $point->y(9);
    $point->clear;

B<Point3Dクラス:>

C<Point3D>は3次元の点を表すクラスです。
C<x>,C<y>,C<z>というアクセッサと、
C<x>,C<y>,C<z>の値を0にクリアする<clear>というメソッドを持ちます。

C<Point3D>はC<Point>を継承して作成されています。
C<clear()>メソッドはC<x>とC<y>とC<z>の値をクリアするために
オーバーライドされています。
    
    package Point3D;
    
    use strict;
    use warnings;
    
    use base 'Point';
    
    __PACKAGE__->attr(z => 0);
    
    sub clear {
        my $self = shift;
        
        $self->SUPER::clear();
        
        $self->z(0);
    }

Point3Dクラスは以下のように利用することができます。

    use Point3D;
    my $point = Point->new(x => 3, y => 5, z => 8);
    print $point->z;
    $point->z(9);
    $point->clear;

=head2 2. オブジェクト指向プログラミングの概念

=head3 継承

L<Object::Simple>をよく理解するために、
オブジェクト指向の概念を解説したいと思います。

オブジェクト指向の一つ目の概念は「継承」です。
「継承」とは「クラスQがクラスPを継承していたら、
クラスQはクラスPのすべてのメソッドを呼び出すことができる」
ということを意味します。

    +---+
    | P | Base class
    +---+   having method1() and method2()
      |
    +---+
    | Q | Sub class
    +---+   having method3()

クラスQはクラスPを継承しているので、
クラスQはクラスQのメソッドに加えて、クラスPのすべてのメソッド
を呼び出すことができます。
言い換えれば、クラスQは
C<method1()>, C<method2()>とC<method3()>
を呼び出すことができます。

継承を行うには、L<base>モジュールを使用します。

    package P;
    
    sub method1 { ... }
    sub method2 { ... }
    
    package Q;
    
    use base 'P';
    
    sub method3 { ... }

Perlはオブジェクト指向プログラミングを助ける
便利な関数とメソッドを持っています。

オブジェクトがどのクラスに属しているかを知るには、
C<ref()>関数を使用します。

    my $class = ref $obj;

オブジェクトが特定のクラスを継承しているかどうかを調べるには、
C<isa()>メソッドを使用します。

    $obj->isa('MyClass');

オブジェクト（あるいはクラス)が特定のメソッドを呼び出す
ことができるかどうかを知るには、
C<can()>メソッドを使用します。

    MyClass->can('method1');
    $obj->can('method1');

=head3 カプセル化

オブジェクト指向プログラミングのふたつ目の概念は
カプセル化です。
「カプセル化」は「内部的にデータに直接アクセスしてはいけない」
ということを意味します。
ドキュメントに記述された公開されたメソッドを使用しなければ
なりません。
このルールを守ることによって、すべてのことがシンプルになります。

このルールを守るためには
値を取得や設定を行うためのアクセッサを生成する
必要があります。

    my $value = $obj->foo;
    $obj->foo(1);

直接データにアクセスするのは良くない習慣です。

    my $value = $obj->{foo}; # Bad manner!
    $obj->{foo} = 1;         # Bad manner!

=head3 ポリモーフィズム

オブジェクト指向プログラミングの三つ目の概念は
「ポリモーフィズム」です。
「ポリモーフィズム」は、
「オーバーロード」と「オーバーライド」のふたつの概念に
分割されます。

Perlプログラマはオーバーロードを気にする必要はありません。
Perlは動的な言語なので、
サブルーチンはどのような値でも受け取ることができます。
オーバーロードはC++やJavaなどの
静的な型を持つ言語にとって価値があります。

「オーバーライド」は「サブクラスにおいて、基底クラスのメソッドを
変更することができる」ということを意味します。

    package P;
    
    sub method1 { return 1 }
    
    package Q;
    
    use base 'P';
    
    sub method1 { return 2 }

クラスPのC<method1()>は1という値を返却します。
クラスQのC<method1()>は2という値を返却します。
つまり、クラスQにおいて、C<method1()>はオーバーライド
されたということです。

    my $obj_a = P->new;
    $obj_p->method1; # Return value is 1
    
    my $obj_b = Q->new;
    $obj_q->method1; # Return value is 2

もし基底クラスのメソッドをサブクラスから呼び出したい場合は
SUPER擬似クラスを使用します。

    package Q;
    
    sub method1 {
        my $self = shift;
        
        my $value = $self->SUPER::method1(); # return value is 1
        
        return 2 + $value;
    }

これらの三つの概念だけを理解するならば、
十分強力なオブジェクト指向プログラムができ、
ソースコードは他の言語のユーザから見ても
読みやすいものになるでしょう。

=head2 3. よく利用するテクニック

=head3 new()のオーバーライド

C<new()>はオーバーライドすることができます。

=head4 オブジェクトの初期化

オブジェクトの初期化処理を行いたい場合は、
new()をオーバーライドすることができます。

    sub new {
        my $self = shift->SUPER::new(@_);
        
        # 初期化処理
        
        return $self;
    }

=head4 new()の引数の変更

new()の引数を変更したい場合は、
new()をオーバーライドすることができます。
    
    sub new {
        my $self = shift;
        
        $self->SUPER::new(x => $_[0], y => $_[1]);
        
        return $self;
    }

C<new()>メソッドをオーバーライドすることによって、
C<new()>に配列を渡すことができるようになりました。

    my $point = Point->new(4, 5);

=head2 4. その他の特徴

=head3 引数のチェック

間違った個数の引数がnew()に渡された場合は
例外が発生します。

    my $obj = MyClass->new(1); # 例外発生!

アクセッサにおいては2つ以上の数の引数が渡された場合に
例外が発生します。

    $obj->foo(a => 1); # 例外発生

=head3 メソッドのインポート

L<Object::Simple>のメソッドをインポートすることもできます。

    package MyClass;
    
    use Object::Simple qw/new attr/;
    
    __PACKAGE__->attr('foo');

C<new()>はクラスにインポートされるのであって、
基底クラスから継承したわけではないので、
C<new()>メソッドをオーバーライドすることはできない
ということに注意してください。

=head3 メソッドチェーン

アクセッサは、値を設定するために呼ばれたときに、
自分自分のオブジェクトを返却するので、メソッドチェーンを
行うことができます。

    $obj->foo(1)->bar(4)->baz(6);

=head3 オブジェクトからのC<attr()>の呼び出し

オブジェクトからC<attr()>を呼び出すこともできます。

    $obj->attr(foo => 1);

対象のオブジェクトが属するクラスにアクセッサが追加されます。

=head2 安定性

(2011/2/23)

L<Object::Simple>はとても安定しています。
L<Object::Simple>は後方互換性を維持することに努めます。

ドキュメントに記述されているメソッドについては
名前を変更したり、取り除いたりすることはないでしょう。

C<class_attr>やC<dual_attr>といった廃止予定のメソッド
は決して利用しないでください。遠い将来十分な期間をおいて、
取り除かれるかもしれません。

=cut
 
1;

